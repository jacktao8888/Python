##__str__()和__repr__()
  例：
    class Person(object):
      def __init__(self, name, gender):
          self.name = name
          self.gender = gender
      def __str__(self):
          return '(Person: %s, %s)' % (self.name, self.gender)
      __repr__ = __str__
    
    p=Person('Bob','Male')
    print p     =>  Person: Bob, Male

##__cmp__()
  Student类实现了按name进行排序：
    >>> L = [Student('Tim', 99), Student('Bob', 88), Student('Alice', 77)]
    >>> print sorted(L)
  [(Alice: 77), (Bob: 88), (Tim: 99)]注意: 如果list不仅仅包含 Student 类，则 __cmp__ 可能会报错：
    L = [Student('Tim', 99), Student('Bob', 88), 100, 'Hello']
    print sorted(L)请思考如何解决。
    
  例：请修改 Student 的 __cmp__ 方法，让它按照分数从高到底排序，分数相同的按名字排序。
    class Student(object):
      def __init__(self, name, score):
        self.name = name
        self.score = score

      def __str__(self):
        return '(%s: %s)' % (self.name, self.score)

      __repr__ = __str__

      def __cmp__(self, s):
        if self.score == s.score:
            return cmp(self.name, s.name)
        return -cmp(self.score, s.score)

    L = [Student('Tim', 99), Student('Bob', 88), Student('Alice', 99)]
    print sorted(L)
    
##__len__():
  里面的显示斐波那契数列的例子没看懂~_~
  
##@property:
  @property,可以将python定义的函数“当做”属性访问，从而提供更加友好访问方式
  例：
    class Student(object):
      def __init__(self, name, score):
        self.name = name
        self.__score = score
      @property
      def score(self):
        return self.__score
      @score.setter
      def score(self, score):
        if score < 0 or score > 100:
            raise ValueError('invalid score')
        self.__score = score
      @property
      def grade(self):
        if self.score < 60:
            return 'C'
        if self.score < 80:
            return 'B'
        return 'A'
    s = Student('Bob', 59)
    print s.grade
    s.score = 60
    print s.grade
    s.score = 99
    print s.grade
  
  
